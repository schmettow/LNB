{
    "contents" : "## Logit-normal distribution functions ####\nlogit <- function(x) log(x/(1-x))\n\ndlogitnorm<-function(x,m,s) dnorm(logit(x),m,s)/(x*(1-x));\n\nrlogitnorm<-function(r,m,s) plogis(rnorm(r,m,s))\n\nlogist<-function(x) 1/(1+exp(-x))\n\nmean.logitnorm<-function(m,s) integrate(function(x,m,s){dlogitnorm(x,m,s)*x},0,1,m=m,s=s)$value\n\nvar.logitnorm<-function(m,s) {\n  mean<-mean.logitnorm(m,s)\n  f<-function(x,m,s){(mean-x)^2*dlogitnorm(x,m,s)}\n  s<-integrate(f,0,1,m=m,s=s)\n  s$value\n}\n\n## Logit-normal binomial distribution functions ####\n\ndlnbinom <- function(x, size, m, s){\n  x = as.integer(x)\n  size = as.integer(size)\n  f=function(P,x,size,m,s) (1-P)^(size-x-1)*P^(x-1)*exp(-(logit(P)-m)^2/(2*s^2))\n  F=function(x,size,m,s) {\n    if(s>0) return(integrate(f,0,1,x,size,m,s,rel.tol=.Machine$double.eps^0.25,subdivisions=100)$value*choose(size,x)/(sqrt(2*pi*s^2)))\n    if(s==0) return(dbinom(x,size,exp(m)))\n    if(s<0) return(0)\n  }\n  #mapply(F,x,size,m,s)\n  tryCatch(mapply(F,x,size,m,s), error=function(cond){return(dlnbinom.mc(x,size,m,s, nruns=10000))})\n  #tryCatch(mapply(F,x,size,m,s), error=function(cond){warning(\"IF\"); return(NaN)})\n}\n\ndlnbinom.mc <- function(x,size,m,s,nruns=100000){\n  #  warning(paste(\"Solving with Monte-Carlo,\",nruns,\"runs\"))\n  f = function(x,size,m,s) freq(rlnbinom(nruns,size,m,s),x)/nruns\n  return(mapply(f,x,size,m,s))\n}\n\nmean.lnbinom<-function(n,m,s) sum(dlnbinom(c(0:n),n,m,s)*c(0:n))\n\nvar.lnbinom<-function(n,m,s) {\n  mean<-mean.lnbinom(n,m,s)\n  #sum(((mean-c(0:n))*dlnbinom(c(0:n),n,m,s))^2)\n  mean((mean-c(0:n))^2*dlnbinom(c(0:n),n,m,s)*n)\n}\n\n\nplnbinom<-function(x,size,m,s) sum(dlnbinom(c(0:x),size,m,s))\nrlnbinom<-function(r,size,m,s) rbinom(r,size,rlogitnorm(r,m,s))\n\n## Zero-runcated LNB ####\ndlnbinom.zt<-function(x,size,m,s){\n  d0<-(1-dlnbinom(0,size,m,s))\n  (x>0)*dlnbinom(x,size,m,s)/d0\n}\n\ndlnbinom.zot<-function(x,size,m,s){\n  d0<-(1-sum(dlnbinom(c(1,2),size,m,s)))\n  (x>1)*dlnbinom(x,size,m,s)/d0\n}\n\n# Logit-normal geometric distribution functions ####\n\ndlngeom<-function(k,m,s) {\n  f<-function(P,k,m,s) dgeom(k,P)*dlogitnorm(P,m,s)\n  F<-function(k,m,s) integrate(f,0,1,k,m,s)$value\n  mapply(F,k,m,s)\n}\n\nplngeom<-function(k,m,s) {\n  F<-function(k,m,s) 1-dlnbinom(0,k+1,m,s)\n  mapply(F,k,m,s)\n}\n\nqlngeom<-function(q,m,s){\n  f<-function(q,m,s){\n    i<-0; \n    while(plngeom(i-1,m,s)<q) {i<-i+1};   \n    return(i)\n  }\n  return(mapply(f,q,m,s))\n}\n\n## Hazard function ####\n\nhlngeom<-function(k,m,s) dlngeom(k,m,s)/(1-plngeom(k,m,s))\nhgeom<-function(k,p) dgeom(k,p)/(1-pgeom(k,p))\n\n## Log-likelihood ####\nnloglik.lnbinom.zt<-function(p,n,K){ \n  K<-K[K>0]\n  if(p[2]>=0){\n    range<-c(c(1:n))\n    frq<-freq(K,range)\n    filter<-frq>0\n    ml<-log(dlnbinom.zt(range[filter],n,p[1],p[2]))\n    nloglik<-(-sum(ml*frq[filter]))\n    return(nloglik)\n  }else{return(-Inf)}\n}\n\n## LNB posterior ####\n\n## TODO: make prior configurable\nlnbzt_posterior <- function(param, K, MS){\n  if(param[2]>=0){\n    occ = unique(MS)\n    frq = freq(MS,occ)\n    ml = log(dlnbinom.zt(occ,K,param[1],param[2]))\n    loglik = sum(ml*frq)\n  }else{loglik = NaN}\n#  loglik = -nloglik.lnbinom.zt.fast(param, K, MS)\n#  mprior = dnorm(param[1], mean=-2, sd=5, log=T)\n#  sprior = dgamma(param[2], 3, 1, log=T)\n  mprior = dnorm(param[1], mean=-2, sd=5, log=T)\n  sprior = dunif(param[2], 0, 10, log=T)\n  loglik + mprior + sprior\n}\n\n## helper function\nfreq<-function(ms, occ = NULL){\n  if(is.null(occ)) occ = unique(ms)\n  sapply(occ, function(x) sum(ms == x))\n}\n",
    "created" : 1409154305041.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3381594396",
    "id" : "4036AA49",
    "lastKnownWriteTime" : 1409127461,
    "path" : "C:/Users/martin/Aktenkoffer/Environments/Github/R Packages/LNB/R/libLNB.R",
    "project_path" : "R/libLNB.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}